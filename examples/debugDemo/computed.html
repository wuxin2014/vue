<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
<div id="app">
  <div>{{ firstName }} {{ fullName }}</div>
  <div>{{ fullName }}</div>
</div>
<script src="../../dist/vue.js"></script>
<script>
  // 依赖收集有3种Watcher: Render Watcher, Computed Watcher, User Watcher
  const vm = new Vue({
    el: '#app',
    data: {
      firstName: '叶',
      lastName: '十七'
    },
    /**
     * 计算属性默认不执行 =》 Object.defineProperty
     * 多次取值如果依赖不变，就不会重新执行
     * 依赖值变化，重新执行
     */
    computed: {
      fullName() { // firstName lastName 会收集fullName计算属性
        console.log('computer===');
        return this.firstName + this.lastName
      },
      // 第二种写法
      // fullName: {
      //   get() {
      //     console.log('oooo')
      //     return this.firstName + this.lastName
      //   },
      //   set(newValue) {
      //     console.log(newValue);
      //   }
      // }
    },
    created() {
      // 声明周期created中取computed的fullname值，注意调试
      console.log(this.fullName)
    }
  });
  setTimeout(() => {
    vm.firstName = '张'
  }, 1000);

  // 计算属性默认不执行 => Object.defineProperty => getter
  // 多次取值如果依赖的值不变化 就不会重新执行  vm.fullName vm.fullName
  // 依赖的值变化 需要重新执行 vm.firstName = 'zhang'  fullName zhangfeng

  // dirty 表示这个值是不是脏的 true （取值后值变为false）， 依赖的值变化了 dirty=>true

  // fullName => 计算属性watcher
  // 计算属性watcher 收集了两个dep (firstName,lastName)

  // 根据计算属性watcher找到这两个dep，让dep收集渲染watcher
  // (firstName,lastName) 收集的渲染watcher

</script>
</body>

</html>
